#!/usr/bin/env bash

set -o pipefail
BASE_MBE_INSTALL_DIR="$HOME/.config/mbe_install"
HISTORY_FILE="$BASE_MBE_INSTALL_DIR/mbe_install.history"
PATCH_DIR="$BASE_MBE_INSTALL_DIR/mbe_install_patches"
mkdir -p "$PATCH_DIR"

timestamp="$(date '+%Y-%m-%dT%H:%M:%S')"
user="$(whoami)"
cwd="$(pwd)"

original_cmd=("$@")

# ---- detect sudo ----
use_sudo=false
cmd_start=0
if [[ "$1" == "sudo" ]]; then
    use_sudo=true
    cmd_start=1
fi

command_name="${original_cmd[$cmd_start]}"
command_args=("${original_cmd[@]:$((cmd_start+1))}")

script_name=$(basename "$0")

if [ $# -eq 0 ]; then
    echo  "This script allow to keep a record of application installation, ran commands "
    echo "and edited files. The goal is to keep a record of what was done when installing "
    echo "a new computer so it is easier to repeat or create/update an ansible playbook"
    echo
    echo "usage:"
    echo -e "\033[1;33m${script_name} <command to log>\033[0m  including \033[1;33m${script_name} sudo <command to log>\033[0m"
    echo -e "\033[1;33m${script_name} nano <file to backup,edit, diff, and log>\033[0m"
    echo -e "\033[1;33m${script_name} info <comments to log>\033[0m"
    echo
    echo "the commands are loggeds in a logfile/history file"
    echo -e "history file location : \033[1;33m${HISTORY_FILE}\033[0m"
    echo
    echo "special commands : "
    echo -e "    \033[4mnano\033[0m -> create a backup file"
    echo "            lauch nano"
    echo "            diff the backup file and the new version"
    echo "            save the differences in a patch file"
    echo "            add the command to the logfile/history"
    echo
    echo "    backup location is the same as original file"
    echo -e "    patch file location : \033[1;33m${PATCH_DIR}\033[0m"
    echo
    echo -e "    \033[4minfo\033[0m -> create a comment entry in the logfile/history"
    echo
    echo -e "    \033[4mshow\033[0m -> display (with less) the logfile/history"
    echo
    exit 0
fi	
meta="at=${timestamp} user=${user} cwd=${cwd}"

backup_path="" 
patch_file=""

# ---- nano pre-processing ----
if [[ "$command_name" == "nano" && "${#command_args[@]}" -ge 1 ]]; then
    target_file="${command_args[0]}"

    if [[ -f "$target_file" ]]; then
        backup_id="$(date '+%Y%m%d%H%M%S')_$$"
        backup_path="${target_file}.bak.${backup_id}"
        patch_file="${PATCH_DIR}/$(basename "$target_file").${backup_id}.patch"

        if $use_sudo; then
            sudo cp --preserve=all "$target_file" "$backup_path"
        else
            cp --preserve=all "$target_file" "$backup_path"
        fi

        if [[ $? -eq 0 ]]; then
            meta+=" backup_id=${backup_id}"
        else
            meta+=" backup=FAILED"
        fi
    else
        meta+=" file=NOT_FOUND"
    fi
fi

if [[ "${command_name}" == "info" ]]; then
    original_cmd[$cmd_start]="# ${original_cmd[$cmd_start]}:"
    info_ind="#"
    exit_code=0
elif [[ "${command_name}" == "show" ]]; then
    less "$HISTORY_FILE"
    exit 0
else
    # ---- execute command ----
    info_ind=""
    "${original_cmd[@]}"
    exit_code=$?
fi

# ---- nano post-processing (diff â†’ patch) ----
if [[ "$command_name" == "nano" && -f "$backup_path" && $exit_code -eq 0 ]]; then
    if $use_sudo; then
        sudo diff -u "$backup_path" "$target_file" > "$patch_file"
    else
        diff -u "$backup_path" "$target_file" > "$patch_file"
    fi

    if [[ -s "$patch_file" ]]; then
        meta+=" patch=$(basename "$patch_file")"
    else
        rm -f "$patch_file"
    fi
fi

# ---- error handling ----
if [[ $exit_code -ne 0 ]]; then
    meta+=" ERROR=${exit_code}"
fi

# ---- single final write ----
if [[ "$info_ind" == "#" ]]; then
    echo "${original_cmd[*]}" >> "$HISTORY_FILE"
else
    echo "${original_cmd[*]}  # ${meta}" >> "$HISTORY_FILE"
fi

exit $exit_code

